#!/usr/bin/env bash
# package_tracking.sh - Package installation tracking system
# Purpose: Track installed packages with their source repositories and metadata

# Source guard to prevent re-sourcing
[[ -n "${_PACKAGE_TRACKING_SOURCED:-}" ]] && return 0
readonly _PACKAGE_TRACKING_SOURCED=1

# Source required modules
source src/core/logging.sh
source src/core/ini_parser.sh

# Tracking database location
readonly TRACKING_DB_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/auto-penguin-setup"
readonly TRACKING_DB_FILE="${TRACKING_DB_DIR}/package_tracking.ini"

# Global flag to check if tracking is initialized
declare -g TRACKING_INITIALIZED=0

# Function: init_package_tracking
# Purpose: Initialize package tracking system and database
# Returns: 0 on success, 1 on failure
init_package_tracking() {
  log_debug "Initializing package tracking system"

  # Create tracking directory if it doesn't exist
  if [[ ! -d "$TRACKING_DB_DIR" ]]; then
    log_debug "Creating tracking database directory: $TRACKING_DB_DIR"
    if ! mkdir -p "$TRACKING_DB_DIR"; then
      log_error "Failed to create tracking database directory"
      return 1
    fi
  fi

  # Create tracking database if it doesn't exist
  if [[ ! -f "$TRACKING_DB_FILE" ]]; then
    log_info "Creating new package tracking database: $TRACKING_DB_FILE"
    if ! _create_tracking_database; then
      log_error "Failed to create tracking database"
      return 1
    fi
  else
    log_debug "Package tracking database exists: $TRACKING_DB_FILE"
  fi

  # Set proper permissions (user read/write only)
  if ! chmod 600 "$TRACKING_DB_FILE"; then
    log_warn "Failed to set tracking database permissions"
  fi

  # Load existing tracking database
  if ! parse_ini_file "$TRACKING_DB_FILE"; then
    log_error "Failed to parse tracking database"
    return 1
  fi

  TRACKING_INITIALIZED=1
  log_success "Package tracking system initialized"
  return 0
}

# Function: _create_tracking_database
# Purpose: Create initial tracking database with metadata
# Returns: 0 on success, 1 on failure
_create_tracking_database() {
  local distro
  distro=$(detect_distro 2>/dev/null) || distro="unknown"

  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  cat >"$TRACKING_DB_FILE" <<EOF
# Package Tracking Database
# Auto-generated by auto-penguin-setup
# DO NOT EDIT MANUALLY - Use tracking functions instead

[metadata]
version=1.0
created_at=$timestamp
last_updated=$timestamp
distro=$distro

EOF

  if [[ ! -f "$TRACKING_DB_FILE" ]]; then
    log_error "Failed to create tracking database file"
    return 1
  fi

  log_debug "Created tracking database with metadata"
  return 0
}

# Function: track_package_install
# Purpose: Record package installation in tracking database
# Arguments:
#   $1 - Package name
#   $2 - Source (COPR:user/repo, AUR:package, PPA:user/repo, flatpak:remote, or "official")
#   $3 - Category (optional, defaults to "uncategorized")
#   $4 - Mapped name (optional, defaults to package name)
#   $5 - Original name (optional, name from packages.ini)
# Returns: 0 on success, 1 on failure
track_package_install() {
  local package_name="$1"
  local source="${2:-official}"
  local category="${3:-uncategorized}"
  local mapped_name="${4:-$package_name}"
  local original_name="${5:-$package_name}"

  if [[ -z "$package_name" ]]; then
    log_error "Package name is required for tracking"
    return 1
  fi

  if [[ "$TRACKING_INITIALIZED" -ne 1 ]]; then
    log_warn "Tracking not initialized, initializing now"
    init_package_tracking || return 1
  fi

  log_debug "Tracking package install: $package_name (source: $source, category: $category)"

  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  # Determine install method based on source
  # Default to pm_install for package-manager installs, use flatpak_install for flatpak sources
  local install_method="pm_install"
  if [[ "$source" == flatpak:* ]]; then
    install_method="flatpak_install"
  fi

  # Create section identifier
  local section="package.${package_name}"

  # Check if package already tracked
  if ini_section_exists "$section"; then
    log_debug "Package already tracked, updating entry: $package_name"
    if ! _update_package_entry "$package_name" "$source" "$category" "$mapped_name" "$original_name" "$timestamp" "$install_method"; then
      log_error "Failed to update package entry"
      return 1
    fi
  else
    log_debug "Adding new package entry: $package_name"
    if ! _add_package_entry "$package_name" "$source" "$category" "$mapped_name" "$original_name" "$timestamp" "$install_method"; then
      log_error "Failed to add package entry"
      return 1
    fi
  fi

  # Update metadata timestamp
  if ! _update_metadata_timestamp "$timestamp"; then
    log_warn "Failed to update metadata timestamp"
  fi

  log_debug "Package tracked: $package_name (original: $original_name, method: $install_method)"
  return 0
}

# Function: track_flatpak_install
# Purpose: Convenience wrapper to track flatpak installs
# Arguments:
#   $1 - Package name (flatpak app id)
#   $2 - Remote (optional, defaults to flathub)
#   $3 - Category (optional, defaults to "uncategorized")
#   $4 - Mapped name (optional, defaults to package name)
#   $5 - Original name (optional, defaults to package name)
# Returns: 0 on success, 1 on failure
track_flatpak_install() {
  local package_name="$1"
  local remote="${2:-flathub}"
  local category="${3:-uncategorized}"
  local mapped_name="${4:-$package_name}"
  local original_name="${5:-$package_name}"
  local source="flatpak:${remote}"

  if [[ -z "$package_name" ]]; then
    log_error "Package name is required for flatpak tracking"
    return 1
  fi

  log_debug "Tracking flatpak install: $package_name (remote: $remote, category: $category)"
  track_package_install "$package_name" "$source" "$category" "$mapped_name" "$original_name"
}

# Function: _add_package_entry
# Purpose: Add new package entry to tracking database
# Arguments:
#   $1 - Package name
#   $2 - Source
#   $3 - Category
#   $4 - Mapped name
#   $5 - Original name
#   $6 - Timestamp
#   $7 - Install method (pm_install, flatpak_install, etc)
# Returns: 0 on success, 1 on failure
_add_package_entry() {
  local package_name="$1"
  local source="$2"
  local category="$3"
  local mapped_name="$4"
  local original_name="$5"
  local timestamp="$6"
  local install_method="${7:-pm_install}"

  cat >>"$TRACKING_DB_FILE" <<EOF
[package.${package_name}]
name=$package_name
original_name=$original_name
source=$source
mapped_name=$mapped_name
installed_at=$timestamp
install_method=$install_method
category=$category

EOF

  # Reload database
  parse_ini_file "$TRACKING_DB_FILE" || return 1

  return 0
}

# Function: _update_package_entry
# Purpose: Update existing package entry in tracking database
# Arguments:
#   $1 - Package name
#   $2 - Source
#   $3 - Category
#   $4 - Mapped name
#   $5 - Original name
#   $6 - Timestamp
#   $7 - Install method
# Returns: 0 on success, 1 on failure
_update_package_entry() {
  local package_name="$1"
  local source="$2"
  local category="$3"
  local mapped_name="$4"
  local original_name="$5"
  local timestamp="$6"
  local install_method="${7:-pm_install}"

  # Read entire file, update the section, write back
  local temp_file="${TRACKING_DB_FILE}.tmp"
  local in_section=0

  while IFS= read -r line || [[ -n "$line" ]]; do
    # Check if we're entering our target section
    if [[ "$line" =~ ^\[package\.${package_name}\]$ ]]; then
      in_section=1
      {
        echo "$line"
        # Write updated values
        echo "name=$package_name"
        echo "original_name=$original_name"
        echo "source=$source"
        echo "mapped_name=$mapped_name"
        echo "installed_at=$timestamp"
        echo "install_method=$install_method"
        echo "category=$category"
      } >>"$temp_file"
      continue
    fi

    # Check if we're entering a different section (exit our section)
    if [[ "$line" =~ ^\[.*\]$ ]] && [[ $in_section -eq 1 ]]; then
      in_section=0
      {
        echo ""
        echo "$line"
      } >>"$temp_file"
      continue
    fi

    # Skip lines in our target section (we already wrote them)
    if [[ $in_section -eq 1 ]]; then
      continue
    fi

    # Copy all other lines
    echo "$line" >>"$temp_file"
  done <"$TRACKING_DB_FILE"

  # Replace original file
  if ! mv "$temp_file" "$TRACKING_DB_FILE"; then
    log_error "Failed to update tracking database"
    rm -f "$temp_file"
    return 1
  fi

  # Reload database
  parse_ini_file "$TRACKING_DB_FILE" || return 1

  return 0
}

# Function: _update_metadata_timestamp
# Purpose: Update last_updated timestamp in metadata section
# Arguments:
#   $1 - Timestamp
# Returns: 0 on success, 1 on failure
_update_metadata_timestamp() {
  local timestamp="$1"

  local temp_file="${TRACKING_DB_FILE}.tmp"

  while IFS= read -r line || [[ -n "$line" ]]; do
    if [[ "$line" =~ ^last_updated= ]]; then
      echo "last_updated=$timestamp" >>"$temp_file"
    else
      echo "$line" >>"$temp_file"
    fi
  done <"$TRACKING_DB_FILE"

  if ! mv "$temp_file" "$TRACKING_DB_FILE"; then
    log_error "Failed to update metadata timestamp"
    rm -f "$temp_file"
    return 1
  fi

  return 0
}

# Function: untrack_package
# Purpose: Remove package from tracking database
# Arguments:
#   $1 - Package name
# Returns: 0 on success, 1 on failure
untrack_package() {
  local package_name="$1"

  if [[ -z "$package_name" ]]; then
    log_error "Package name is required"
    return 1
  fi

  if [[ "$TRACKING_INITIALIZED" -ne 1 ]]; then
    log_warn "Tracking not initialized"
    return 1
  fi

  local section="package.${package_name}"

  if ! ini_section_exists "$section"; then
    log_warn "Package not tracked: $package_name"
    return 1
  fi

  log_debug "Removing package from tracking: $package_name"

  # Remove section from file
  local temp_file="${TRACKING_DB_FILE}.tmp"
  local in_section=0

  while IFS= read -r line || [[ -n "$line" ]]; do
    # Check if we're entering the target section
    if [[ "$line" =~ ^\[package\.${package_name}\]$ ]]; then
      in_section=1
      continue
    fi

    # Check if we're entering a different section
    if [[ "$line" =~ ^\[.*\]$ ]] && [[ $in_section -eq 1 ]]; then
      in_section=0
      echo "$line" >>"$temp_file"
      continue
    fi

    # Skip lines in target section
    if [[ $in_section -eq 1 ]]; then
      continue
    fi

    # Copy all other lines
    echo "$line" >>"$temp_file"
  done <"$TRACKING_DB_FILE"

  if ! mv "$temp_file" "$TRACKING_DB_FILE"; then
    log_error "Failed to remove package from tracking"
    rm -f "$temp_file"
    return 1
  fi

  # Reload database
  parse_ini_file "$TRACKING_DB_FILE" || return 1

  log_success "Package untracked: $package_name"
  return 0
}

# Function: get_tracked_packages
# Purpose: Get list of all tracked packages
# Returns: List of package names (one per line)
get_tracked_packages() {
  if [[ "$TRACKING_INITIALIZED" -ne 1 ]]; then
    log_warn "Tracking not initialized"
    return 1
  fi

  local sections
  sections=$(list_ini_sections)

  while IFS= read -r section; do
    if [[ "$section" =~ ^package\.(.+)$ ]]; then
      echo "${BASH_REMATCH[1]}"
    fi
  done <<<"$sections"

  return 0
}

# Function: get_package_info
# Purpose: Get information about a tracked package
# Arguments:
#   $1 - Package name
# Returns: Package info (key=value pairs)
get_package_info() {
  local package_name="$1"

  if [[ -z "$package_name" ]]; then
    log_error "Package name is required"
    return 1
  fi

  if [[ "$TRACKING_INITIALIZED" -ne 1 ]]; then
    log_warn "Tracking not initialized"
    return 1
  fi

  local section="package.${package_name}"

  if ! ini_section_exists "$section"; then
    log_error "Package not tracked: $package_name"
    return 1
  fi

  # Get all keys in section
  local keys
  keys=$(get_ini_section_keys "$section")

  while IFS= read -r key; do
    local value
    value=$(get_ini_value "$section" "$key")
    echo "$key=$value"
  done <<<"$keys"

  return 0
}

# Function: get_package_source
# Purpose: Get source repository for a package
# Arguments:
#   $1 - Package name
# Returns: Source string or empty
get_package_source() {
  local package_name="$1"

  if [[ -z "$package_name" ]]; then
    return 1
  fi

  if [[ "$TRACKING_INITIALIZED" -ne 1 ]]; then
    return 1
  fi

  local section="package.${package_name}"
  get_ini_value "$section" "source"
}

# Function: get_packages_from_repo
# Purpose: Get all packages installed from a specific repository
# Arguments:
#   $1 - Repository source (e.g., "COPR:user/repo" or "AUR:package")
# Returns: List of package names (one per line)
get_packages_from_repo() {
  local repo_source="$1"

  if [[ -z "$repo_source" ]]; then
    log_error "Repository source is required"
    return 1
  fi

  if [[ "$TRACKING_INITIALIZED" -ne 1 ]]; then
    log_warn "Tracking not initialized"
    return 1
  fi

  log_debug "Finding packages from repository: $repo_source"

  local packages
  packages=$(get_tracked_packages)

  local found_count=0
  while IFS= read -r package; do
    [[ -z "$package" ]] && continue

    local source
    source=$(get_package_source "$package")

    if [[ "$source" == "$repo_source" ]]; then
      echo "$package"
      ((found_count++))
    fi
  done <<<"$packages"

  log_debug "Found $found_count packages from repository: $repo_source"
  return 0
}

# Function: is_package_tracked
# Purpose: Check if a package is tracked
# Arguments:
#   $1 - Package name
# Returns: 0 if tracked, 1 if not
is_package_tracked() {
  local package_name="$1"

  if [[ -z "$package_name" ]]; then
    return 1
  fi

  if [[ "$TRACKING_INITIALIZED" -ne 1 ]]; then
    return 1
  fi

  local section="package.${package_name}"
  ini_section_exists "$section"
}

# Function: list_tracked_packages
# Purpose: Display all tracked packages in human-readable format
# Returns: 0 on success
list_tracked_packages() {
  if [[ "$TRACKING_INITIALIZED" -ne 1 ]]; then
    log_error "Tracking not initialized"
    return 1
  fi

  local packages
  packages=$(get_tracked_packages)

  if [[ -z "$packages" ]]; then
    log_info "No packages tracked yet"
    return 0
  fi

  echo "Tracked Packages:"
  echo "================================================================================"
  printf "%-25s %-25s %-20s %-15s %s\n" "ORIGINAL NAME" "INSTALLED NAME" "SOURCE" "CATEGORY" "INSTALLED AT"
  echo "================================================================================"

  while IFS= read -r package; do
    [[ -z "$package" ]] && continue

    local original_name
    local installed_name
    local source
    local category
    local installed_at

    original_name=$(get_ini_value "package.${package}" "original_name")
    installed_name=$(get_ini_value "package.${package}" "name")
    source=$(get_ini_value "package.${package}" "source")
    category=$(get_ini_value "package.${package}" "category")
    installed_at=$(get_ini_value "package.${package}" "installed_at")

    # If no original_name, use installed_name
    [[ -z "$original_name" ]] && original_name="$installed_name"

    printf "%-25s %-25s %-20s %-15s %s\n" "$original_name" "$installed_name" "$source" "$category" "$installed_at"
  done <<<"$packages"

  return 0
}

# Function: get_tracking_stats
# Purpose: Get statistics about tracked packages
# Returns: Stats in key=value format
get_tracking_stats() {
  if [[ "$TRACKING_INITIALIZED" -ne 1 ]]; then
    log_error "Tracking not initialized"
    return 1
  fi

  local packages
  packages=$(get_tracked_packages)

  local total=0
  local copr=0
  local aur=0
  local ppa=0
  local official=0
  local flatpak=0

  while IFS= read -r package; do
    [[ -z "$package" ]] && continue
    ((total++))

    local source
    source=$(get_package_source "$package")

    case "$source" in
    COPR:*)
      ((copr++))
      ;;
    AUR:*)
      ((aur++))
      ;;
    PPA:*)
      ((ppa++))
      ;;
    flatpak:*)
      ((flatpak++))
      ;;
    official)
      ((official++))
      ;;
    esac
  done <<<"$packages"

  echo "total=$total"
  echo "copr=$copr"
  echo "aur=$aur"
  echo "ppa=$ppa"
  echo "official=$official"
  echo "flatpak=$flatpak"

  return 0
}

export -f init_package_tracking
export -f track_package_install
export -f track_flatpak_install
export -f untrack_package
export -f get_tracked_packages
export -f get_package_info
export -f get_package_source
export -f get_packages_from_repo
export -f is_package_tracked
export -f list_tracked_packages
export -f get_tracking_stats
